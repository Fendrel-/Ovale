import { format } from "@wowts/string";
import {
    existsSync,
    mkdirSync,
    readFileSync,
    readdirSync,
    writeFileSync,
} from "fs";
import { eventDispatcher, ClassId } from "@wowts/wow-mock";
import { registerScripts } from "../scripts/index";
import { getSpellData, SpellData } from "./importspells";
import { ipairs } from "@wowts/lua";
import {
    convertFromSpellData,
    CustomAura,
    CustomAuras,
    CustomSpellData,
} from "./customspell";
import { SpellInfoProperty } from "../engine/data";
import { IoC } from "../ioc";

const outputDirectory = "src/scripts";
const simcDirectory = process.argv[2];
const profilesDirectory = simcDirectory + "/profiles/Tier25";
const SIMC_CLASS = [
    "deathknight",
    "demonhunter",
    "druid",
    "hunter",
    "mage",
    "monk",
    "paladin",
    "priest",
    "rogue",
    "shaman",
    "warlock",
    "warrior",
];

function Canonicalize(s: string) {
    const token = "xXxUnDeRsCoReXxX";
    s = s.toLowerCase();
    s = s.replace(/[\s\-_(){}[\]]/g, token);
    s = s.replace(/\./g, "");
    s = s.replace(/xXxUnDeRsCoReXxX/g, "_");
    s = s.replace("_+", "_");
    s = s.replace("^_", "");
    s = s.replace("_$", "");
    return s;
}

if (!existsSync(outputDirectory)) mkdirSync(outputDirectory);

const spellData = getSpellData(simcDirectory);

// function escapeString(s: string) {
//     if (!s) return s;
//     return s.replace(/"/, '\\"');
// }

if (existsSync("../wow-mock")) {
    let spellInfos = `export const spellInfos:{[k: number]: { name: string, castTime: number, minRange: number, maxRange: number }} = {\n`;
    for (const [spellId, data] of spellData.spellDataById) {
        spellInfos += ` 	[${spellId}]: { name: "${data.name}", castTime: ${data.cast_time}, minRange: ${data.min_range}, maxRange: ${data.max_range}},\n`;
    }
    spellInfos += "};";
    spellInfos += `export const enum SpellId {
        ${Array.from(spellData.spellDataById.values())
            .filter(
                (x) =>
                    !x.identifier.match(/_unused/) &&
                    !x.identifier.match(/_(\d)$/)
            )
            .map((x) => ` 	${x.identifier} = ${x.id},`)
            .join("\n")}
}
`;
    writeFileSync("../wow-mock/src/spells.ts", spellInfos, {
        encoding: "utf8",
    });

    let talentInfos = `export const enum TalentId {
${Array.from(spellData.talentsById.values())
    .map((x) => ` 	${x.identifier} = ${x.id},`)
    .join("\n")}
}

export const enum TalentIndex {
${Array.from(spellData.talentsById.values())
    .map((x) => `    ${x.identifier} = ${x.talentId},`)
    .join("\n")}
}
`;

    writeFileSync("../wow-mock/src/talents.ts", talentInfos, {
        encoding: "utf8",
    });
}

const limitLine1 = "// THE REST OF THIS FILE IS AUTOMATICALLY GENERATED";
const limitLine2 = "// ANY CHANGES MADE BELOW THIS POINT WILL BE LOST";

function truncateFile(fileName: string) {
    const file = readFileSync(fileName, { encoding: "utf8" });
    const lines = file.split("\n");
    const output: string[] = [];
    for (const line of lines) {
        if (line.indexOf(limitLine1) >= 0) {
            break;
        }
        output.push(line);
    }
    output.push(limitLine1);
    output.push(limitLine2);
    output.push("");
    writeFileSync(fileName, output.join("\n"));
}

const modifiedFiles = new Map<string, boolean>();

const files: string[] = [];
const profileFile = process.argv[3];
if (profileFile) {
    files.push(process.argv[3]);
} else {
    const dir = readdirSync(profilesDirectory);
    for (const name of dir) {
        files.push(name);
    }
    files.sort();
}

const spellsByClass = new Map<string, number[]>();
const talentsByClass = new Map<string, number[]>();
const itemsByClass = new Map<string, number[]>();
const spellListsByClass = new Map<string, string[]>();
const azeriteTraitByClass = new Map<string, number[]>();
const essenceByClass = new Map<string, number[]>();
const runeforgeByClass = new Map<string, number[]>();
const conduitByClass = new Map<string, number[]>();
const soulbindAbilityByClass = new Map<string, number[]>();
const customByClass = new Map<string, number[]>();

function getOrSet<T>(map: Map<string, T[]>, className: string) {
    let result = map.get(className);
    if (result) return result;
    result = [];
    map.set(className, result);
    return result;
}

function addId<T>(ids: T[], id?: T) {
    if (id && !ids.includes(id)) {
        ids.push(id);
    }
}

const customIdentifiers = new Map<string, number>();

// Pets and demons
customIdentifiers.set("wild_imp_inner_demons", 143622);
customIdentifiers.set("vilefiend", 135816);
customIdentifiers.set("demonic_tyrant", 135002);
customIdentifiers.set("wild_imp", 55659);
customIdentifiers.set("dreadstalker", 98035);
customIdentifiers.set("darkglare", 103673);
customIdentifiers.set("infernal", 89);
customIdentifiers.set("felguard", 17252);

// Enchantments
customIdentifiers.set("fallen_crusader_enchant", 3368);
customIdentifiers.set("razorice_enchant", 3370);

// Spells missing in the database
customIdentifiers.set("hex", 51514);
customIdentifiers.set("lunar_empowerment", 292664);
customIdentifiers.set("solar_empowerment", 292663);

// Invisible auras
customIdentifiers.set("garrote_exsanguinated", -703);
customIdentifiers.set("rupture_exsanguinated", -1943);
customIdentifiers.set("bt_swipe_buff", -106785);
customIdentifiers.set("bt_thrash_buff", -106830);
customIdentifiers.set("bt_rake_buff", -1822);
customIdentifiers.set("bt_shred_buff", -5221);
customIdentifiers.set("bt_brutal_slash_buff", -202028);
customIdentifiers.set("bt_moonfire_buff", -155625);

// Custom spell lists
function addSpellList(name: string, ...identifiers: string[]) {
    spellData.spellLists.set(
        name,
        identifiers.map((identifier) => ({
            identifier,
            id:
                spellData.identifiers[identifier] ??
                customIdentifiers.get(identifier) ??
                0,
        }))
    );
}
addSpellList("exsanguinated", "garrote_exsanguinated", "rupture_exsanguinated");
addSpellList(
    "starsurge_empowerment_buff",
    "lunar_empowerment",
    "solar_empowerment"
);
addSpellList("eclipse_any", "eclipse_lunar", "eclipse_solar");
addSpellList(
    "bt_buffs",
    "bt_swipe_buff",
    "bt_thrash_buff",
    "bt_shred_buff",
    "bt_brutal_slash_buff",
    "bt_moonfire_buff",
    "bt_rake_buff"
);
addSpellList(
    "bs_inc_buff",
    "incarnation_king_of_the_jungle",
    "incarnation_guardian_of_ursoc",
    "berserk_bear",
    "berserk_cat"
);

// Fix identifiers
function fixIdentifier(identifier: string, spellId: number) {
    const spell = spellData.spellDataById.get(spellId);
    if (spell) {
        delete spellData.identifiers[spell.identifier];
        spell.identifier = identifier;
        spellData.identifiers[identifier] = spellId;
    }
}
fixIdentifier("shining_light_free_buff", 327510);
fixIdentifier("sun_kings_blessing_ready_buff", 333315);
fixIdentifier("clearcasting_channel_buff", 277726);
fixIdentifier("balance_of_all_things_arcane_buff", 339946);
fixIdentifier("balance_of_all_things_nature_buff", 339943);
fixIdentifier("adaptive_swarm_damage", 325733);
fixIdentifier("adaptive_swarm_heal", 325748);
fixIdentifier("kindred_empowerment_energize", 327139);

// TODO add _cat/_bear using required stance
fixIdentifier("wild_charge_bear", 16979);
fixIdentifier("wild_charge_cat", 49376);
fixIdentifier("thrash_cat", 106830);
fixIdentifier("swipe_cat", 106785);
fixIdentifier("moonfire_cat", 155625);
fixIdentifier("berserk_cat", 106951);
fixIdentifier("berserk_bear", 50334);

addSpellList("wild_charge", "wild_charge_bear", "wild_charge_cat");
addSpellList("adaptive_swarm", "adaptive_swarm_damage", "adaptive_swarm_heal");
addSpellList("berserk", "berserk_cat", "berserk_bear");

const customIdentifierById = new Map<
    number,
    { id: number; identifier: string }
>();

for (const [key, value] of customIdentifiers.entries()) {
    spellData.identifiers[key] = value;
    customIdentifierById.set(value, { identifier: key, id: value });
}

for (const filename of files) {
    if (!filename.startsWith("generate")) {
        const output: string[] = [];
        const inputName = profilesDirectory + "/" + filename;
        const simc = readFileSync(inputName, { encoding: "utf8" });
        if (simc.indexOf("optimal_raid=") < 0) {
            let source: string | undefined,
                className: string | undefined,
                specialization: string | undefined;
            const matches = simc.match(/[^\r\n]+/g);
            if (matches) {
                for (const line of matches) {
                    if (!source) {
                        if (line.substring(0, 3) == "### ") {
                            source = line.substring(4);
                        }
                    }
                    if (!className) {
                        for (const simcClass of SIMC_CLASS) {
                            const length = simcClass.length;
                            if (
                                line.substring(0, length + 1) ==
                                simcClass + "="
                            ) {
                                className = simcClass.toUpperCase();
                            }
                        }
                    }
                    if (!specialization) {
                        if (line.substring(0, 5) == "spec=") {
                            specialization = line.substring(5);
                        }
                    }
                    if (className && specialization) {
                        break;
                    }
                }
            }

            if (!className || !specialization) {
                console.log("className and specialization must be defined");
                continue;
            }

            console.log(filename);
            const ioc = new IoC();
            ioc.ovale.playerGUID = "player";
            ioc.ovale.playerClass = <ClassId>className;
            for (const [key] of spellData.spellLists) {
                ioc.data.buffSpellList[key] = {};
            }
            eventDispatcher.DispatchEvent("ADDON_LOADED", "Ovale");
            eventDispatcher.DispatchEvent("PLAYER_ENTERING_WORLD", "Ovale");
            registerScripts(ioc.scripts);

            const profile = ioc.simulationCraft.ParseProfile(
                simc,
                Object.assign({}, spellData.identifiers)
            );
            if (!profile) continue;
            const profileName = profile.annotation.name.substring(
                1,
                profile.annotation.name.length - 1
            );
            let desc: string;
            if (source) {
                desc = format("%s: %s", source, profileName);
            } else {
                desc = profileName;
            }
            const name = Canonicalize(desc);
            output.push("");
            output.push("{");
            output.push(format('	const name = "sc_%s"', name));
            output.push(
                format('	const desc = "[9.0] Simulationcraft: %s"', desc)
            );
            output.push("	const code = `");
            output.push(ioc.simulationCraft.Emit(profile, true));
            output.push("`");
            output.push(
                format(
                    '	OvaleScripts.RegisterScript("%s", "%s", name, desc, code, "%s")',
                    profile.annotation.classId,
                    profile.annotation.specialization,
                    "script"
                )
            );
            output.push("}");
            output.push("");

            const outputFileName = "ovale_" + className.toLowerCase() + ".ts";
            console.log("Appending to " + outputFileName + ": " + name);
            const outputName = outputDirectory + "/" + outputFileName;
            if (!modifiedFiles.get(outputName)) {
                modifiedFiles.set(outputName, true);
                truncateFile(outputName);
            }
            writeFileSync(outputName, output.join("\n"), { flag: "a" });

            const classSpells = getOrSet(spellsByClass, className);
            const classTalents = getOrSet(talentsByClass, className);
            const classItems = getOrSet(itemsByClass, className);
            const azeriteTraits = getOrSet(azeriteTraitByClass, className);
            const essences = getOrSet(essenceByClass, className);
            const spellLists = getOrSet(spellListsByClass, className);
            const runeforges = getOrSet(runeforgeByClass, className);
            const conduits = getOrSet(conduitByClass, className);
            const soulbindAbilities = getOrSet(
                soulbindAbilityByClass,
                className
            );
            const custom = getOrSet(customByClass, className);

            const identifiers = ipairs(profile.annotation.symbolList)
                .map((x) => x[1])
                .sort();
            for (const symbol of identifiers) {
                const spellList = spellData.spellLists.get(symbol);
                if (spellList) {
                    for (const spell of spellList) {
                        if (customIdentifierById.has(spell.id))
                            addId(custom, spell.id);
                        else addId(classSpells, spell.id);
                    }
                    if (spellLists.indexOf(symbol) < 0) spellLists.push(symbol);
                    continue;
                }
                const id = spellData.identifiers[symbol];
                if (customIdentifiers.has(symbol)) addId(custom, id);
                else if (symbol.match(/_talent/)) {
                    addId(classTalents, id);
                } else if (symbol.match(/_item$/)) {
                    addId(classItems, id);
                } else if (symbol.match(/_trait$/)) {
                    addId(azeriteTraits, id);
                } else if (symbol.match(/_essence_id$/)) {
                    addId(essences, id);
                } else if (symbol.match(/_runeforge$/)) {
                    addId(runeforges, id);
                } else if (symbol.match(/_conduit$/)) {
                    addId(conduits, id);
                } else if (symbol.match(/_soulbind$/)) {
                    addId(soulbindAbilities, id);
                } else {
                    if (id && classSpells.indexOf(id) < 0) {
                        classSpells.push(id);
                    }
                }
            }
        }
    }
}

function getTooltip(spell: CustomSpellData | SpellData) {
    return spell.tooltip && spell.tooltip.replace(/[$\\{}%]/g, "");
}

function getDesc(spell: CustomSpellData | SpellData) {
    return spell.desc && spell.desc.replace(/[$\\{}%]/g, "");
}

function getBuffDefinition(
    identifier: string,
    target: keyof CustomAuras,
    customAura: CustomAura
) {
    const spell = spellData.spellDataById.get(customAura.id);
    if (!spell) return `# Unknown spell id ${customAura.id}`;
    let ret = "";
    if (spell.tooltip) {
        ret = `  # ${getTooltip(spell)}\n`;
    }
    if (target === "player") {
        return `${ret}  SpellAddBuff(${identifier} ${spell.identifier} add=${customAura.stacks})`;
    }
    return `${ret}  SpellAddTargetDebuff(${identifier} ${spell.identifier} add=${customAura.stacks})`;
}

// function getConditions(conditions: Condition[], talentIds: number[]) {
//     let output = "";
//     for (const key of conditions) {
//         if (key.type === "talent") {
//             const talentId = key.id;
//             if (talentId) {
//                 const talent = spellData.talentsById.get(talentId);
//                 if (talent) {
//                     output += ` hastalent(${talent.identifier})`;
//                     if (talentIds.indexOf(talentId) < 0)
//                         talentIds.push(talentId);
//                 }
//             }
//         }
//     }
//     return output;
// }

function getDefinition(
    identifier: string,
    customSpellData: CustomSpellData,
    talentIds: number[],
    spellIds: number[]
) {
    let output = customSpellData.desc ? `# ${getDesc(customSpellData)}\n` : "";
    if (customSpellData.nextRank) {
        const nextRank = spellData.spellDataById.get(customSpellData.nextRank);
        if (nextRank && nextRank.desc) {
            output += `# ${nextRank.rank_str}: ${getDesc(nextRank)}\n`;
        }
    }

    output += `  SpellInfo(${identifier}`;
    for (const key in customSpellData.spellInfo) {
        if (key === "require") continue;
        output += ` ${key}=${
            customSpellData.spellInfo[key as SpellInfoProperty]
        }`;
    }

    // if (customSpellData.conditions)
    //     output += getConditions(customSpellData.conditions, talentIds);

    output += `)\n`;

    for (const require of customSpellData.require) {
        let parameter;
        if (require.talentId) {
            parameter = spellData.talentsById.get(require.talentId)?.identifier;
            talentIds.push(require.talentId);
        } else if (require.specializationName) {
            parameter = require.specializationName.join(" ");
        }
        output += `  SpellRequire(${customSpellData.identifier} ${
            require.property
        } set=${require.value} enabled=(${require.not ? "not " : ""}${
            require.condition
        }(${parameter ?? ""})))\n`;
    }

    const auras = customSpellData.auras;
    if (auras) {
        for (const key in auras) {
            const k = key as keyof CustomAuras;
            const aura = auras[k];
            if (aura) {
                output += aura
                    .filter((x) => spellIds.indexOf(x.id) >= 0)
                    .map((x) => getBuffDefinition(identifier, k, x))
                    .join("\n");
                output += "\n";
            }
        }
    }
    return output;
}

for (const file of modifiedFiles.keys()) {
    writeFileSync(file, "\n}", { encoding: "utf8", flag: "a" });
}

function isDefined<T>(t: T | undefined): t is T {
    return t !== undefined;
}

for (const [className, spellIds] of spellsByClass) {
    let output = `// THIS PART OF THIS FILE IS AUTOMATICALLY GENERATED
${limitLine2}
    let code = \``;
    const talentIds = talentsByClass.get(className) || [];
    const spells: CustomSpellData[] = [];
    const remainingsSpellIds = spellIds.concat();
    const addSpells = (addedIds: number[]) => {
        for (const spellId of addedIds) {
            if (
                remainingsSpellIds.indexOf(spellId) < 0 &&
                spellIds.indexOf(spellId) < 0
            ) {
                remainingsSpellIds.push(spellId);
                spellIds.push(spellId);
            }
        }
    };
    while (remainingsSpellIds.length) {
        const spellId = remainingsSpellIds.pop();
        if (!spellId) continue;
        const spell = spellData.spellDataById.get(spellId);
        if (!spell) {
            continue;
        }
        if (spell.replaced_by) {
            addSpells(spell.replaced_by);
        }

        const customSpell = convertFromSpellData(
            spell,
            spellData.spellDataById
        );
        spells.push(customSpell);
        if (customSpell.auras) {
            for (const t in customSpell.auras) {
                const target = t as keyof CustomAuras;
                const auras = customSpell.auras[target];
                if (auras) {
                    addSpells(auras.map((x) => x.id));
                }
            }
        }
    }

    const sortedSpells = spells.sort((x, y) =>
        x.identifier < y.identifier ? -1 : 1
    );
    for (const spell of sortedSpells) {
        if (!spell) continue;
        output += `Define(${spell.identifier} ${spell.id})\n`;
        output += getDefinition(spell.identifier, spell, talentIds, spellIds);
        //         if (!buffAdded && !debuffAdded && !spell.tooltip && spell.duration) {
        //             output += `Define(${spell.identifier}_dummy -${spell.id})
        //     SpellInfo(${spell.identifier}_dummy duration=${spell.duration})
        //     SpellAddBuff(${spell.identifier} ${spell.identifier}_dummy=1)
        // `
        //         }
    }

    const spellLists = spellListsByClass.get(className);
    if (spellLists) {
        for (const spellList of spellLists) {
            const spells = spellData.spellLists.get(spellList);
            if (spells) {
                output += `SpellList(${spellList} ${spells
                    .map((x) => x.identifier)
                    .join(" ")})\n`;
            }
        }
    }

    const talents = talentIds
        .map((x) => spellData.talentsById.get(x))
        .filter(isDefined)
        .sort((x, y) => (x.name > y.name ? 1 : -1));
    for (let i = 0; i < talents.length; i++) {
        const talent = talents[i];
        if (!talent) continue;
        output += `Define(${talent.identifier} ${talent.talentId}) #${talent.id}\n`;
        const spell = spellData.spellDataById.get(talent.spell_id);
        if (spell && spell.desc) {
            output += `# ${getDesc(spell)}\n`;
        }
    }

    const writeIds = <T, U extends { identifier: string }>(
        idInSimc: Map<string, T[]>,
        repository: Map<T, U>,
        idProperty: keyof U
    ) => {
        const ids = idInSimc.get(className);
        if (ids) {
            for (const id of ids) {
                const item = repository.get(id);
                if (!item) continue;
                output += `Define(${item.identifier} ${item[idProperty]})\n`;
            }
        }
    };

    writeIds(customByClass, customIdentifierById, "id");
    writeIds(itemsByClass, spellData.itemsById, "id");
    writeIds(azeriteTraitByClass, spellData.azeriteTraitById, "spellId");
    writeIds(essenceByClass, spellData.essenceById, "id");
    writeIds(runeforgeByClass, spellData.runeforgeById, "bonus_id");
    writeIds(conduitByClass, spellData.conduitById, "id");
    writeIds(soulbindAbilityByClass, spellData.soulbindAbilityById, "spell_id");

    output += `    \`;
// END`;

    const fileName = outputDirectory + "/ovale_" + className + "_spells.ts";
    let existing = readFileSync(fileName, { encoding: "utf8" });
    const lines = output.split("\n");
    for (const line of lines) {
        if (line.indexOf("//") >= 0 || line.indexOf("`") >= 0) continue;
        existing = existing.split(line.trim()).join("");
    }
    output = existing.replace(
        /\/\/ THIS PART OF THIS FILE IS AUTOMATICALLY GENERATED[^]*\/\/ END/,
        output
    );
    writeFileSync(fileName, output, { encoding: "utf8" });

    // writeCustomSpell(sortedSpells, className, spellData.spellDataById);
}
